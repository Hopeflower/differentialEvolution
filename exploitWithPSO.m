function [xBest, fitXBest] = exploitWithPSO(xBest, x1, x2, x3, fitXBest, fitX1, fitX2, fitX3, spaceSize, totalPixels, normProba, maxThresh, minThresh)

c1=1;%factor particle trusts itself
c2=2;%factor particle trusts global best
numGenerations = 30;
rd = numGenerations;%regeneration distance
%---use thresholds as particles
vel = zeros(3, 1);%number of x's
fitnessU = []; U = [];
pBestY = [x1 x2 x3];
pBestFit = [fitX1 fitX2 fitX3];
gloBestY = xBest;
bestFitnessYet = fitXBest;
thresh = size(xBest,1);

for g = 1:numGenerations
for t = 1:thresh
    y = [x1(t); x2(t); x3(t)];%move toward xBest(t)    
    r = rand(2,1);

    particleOwn = (c1*r(1)) .* (pBestY(t, :)' - y(:));
    particleSocial = (c2*r(2)) .* (gloBestY(t, :) - y(:));
    y(:) = y(:) + particleOwn + particleSocial;
    x1(t) = round(y(1)); x2(t) = round(y(2)); x3(t) = round(y(3)); 
end%for t
%---clamping
x1(x1 > maxThresh) = maxThresh - 1;
x1(x1 < minThresh) = minThresh + 1;
x2(x2 > maxThresh) = maxThresh - 1;
x2(x2 < minThresh) = minThresh + 1;
x3(x3 > maxThresh) = maxThresh - 1;
x3(x3 < minThresh) = minThresh + 1;
%---check for better fitness
[fitnessU, U] = OtsuFitness([x1 x2 x3], spaceSize, totalPixels, normProba);
[val, fittest] = max(fitnessU);
if val > bestFitnessYet, bestFitnessYet = val; gloBestY = U(:, fittest);end%update global best
%---update personal best's
if fitnessU(1) > pBestFit(1), pBestFit(1) = fitnessU(1); pBestY(:, 1) = x1(:);end
if fitnessU(2) > pBestFit(2), pBestFit(2) = fitnessU(2); pBestY(:, 2) = x2(:);end
if fitnessU(3) > pBestFit(3), pBestFit(3) = fitnessU(3); pBestY(:, 3) = x3(:);end
end%for g

if bestFitnessYet > fitXBest,
    xBest = gloBestY;
    fitXBest = bestFitnessYet;
end